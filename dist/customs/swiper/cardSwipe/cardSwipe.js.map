{"version":3,"file":"customs/swiper/cardSwipe/cardSwipe.js","sources":["webpack:///._src_customs_swiper_cardSwipe_cardSwipe.js"],"sourcesContent":["/*\n * @Author: jesse zhao \n * @Date: 2020-04-07 02:41:53 \n * @Last Modified by: jesse zhao\n * @Last Modified time: 2020-04-20 03:13:52\n * @github: https://github.com/1esse/cardSwipe\n */\n\nComponent({\n  properties: {\n    cards: Array, // 卡片数据，一个包含所有卡片对象的数组\n    removedCards: Array, // 存放已经移除的卡片的索引数据，如果索引填充了其他卡片，需要将该索引移出\n    transition: Boolean, // 是否开启过渡动画\n    circling: Boolean, // 是否列表循环\n    rotateDeg: Number, // 整个滑动过程旋转角度\n    showCards: { // 显示几张卡片\n      type: Number,\n      value: 3\n    },\n    slideDuration: { // 手指离开屏幕后滑出界面时长，单位(ms)毫秒\n      type: Number,\n      value: 200\n    },\n    slideThershold: { // 松手后滑出界面阈值，单位px\n      type: Number,\n      value: 60\n    },\n    upHeight: { // 下层卡片下移高度，单位px\n      type: Number,\n      value: 30\n    },\n    scaleRatio: { // 下层卡片收缩力度\n      type: Number,\n      value: 0.05\n    },\n  },\n\n  observers: {\n    cards(nc, oc) {\n      if (!nc) return\n      this.cardReflect()\n    },\n    showCards(nc, oc) { // 用于展示调节用，一般情况下展示卡片数量是固定的，不需要监听变化。\n      if (!nc) return\n      this.cardReflect()\n    }\n  },\n\n  data: {\n    just_shown: -1, // 如果显示卡片的数量和卡片总数量一样，那么开启循环的时候，被设置过transform的节点不会重新渲染，这会导致已经滑出界面的卡片无法回归原位，这个字段就是用来控制滑出卡片重新渲染的\n  },\n\n  attached() {\n    // 给每张卡片设置层级\n    const { cards } = this.data\n    this.setData({\n      current_cursor: cards.findIndex(item => item)\n    })\n    this.getContextWidth()\n  },\n\n  methods: {\n    cardReflect() {\n      let { cards, showCards } = this.data\n      let sc = showCards\n      if (showCards < 1) sc = 1\n      else if (showCards > cards.filter(item => item).length) sc = cards.filter(item => item).length\n      this.setData({\n        current_z_index: new Array(sc).fill(0).map((_, index) => index + 1).reverse(),\n        sc: sc\n      })\n    },\n\n    getContextWidth() {\n      const query = this.createSelectorQuery()\n      query.select('.wrapper').boundingClientRect()\n      query.exec((res) => {\n        const contextWidth = res[0].width\n        this.setData({\n          contextWidth\n        })\n      })\n    },\n    nextCard(e) {\n      let { current_cursor, just_shown, slideDuration } = this.data\n      just_shown = current_cursor\n      current_cursor = this.countCurrentCursor(current_cursor)\n      Object.assign(e, {\n        swiped_card_index: just_shown,\n        current_cursor\n      })\n      setTimeout(() => {\n        this.setData({\n          just_shown\n        }, () => {\n          this.setData({\n            just_shown: -1,\n            current_cursor,\n          })\n        })\n      }, slideDuration)\n      this.triggerEvent('cardSwipe', e)\n    },\n\n    countCurrentCursor(current_cursor) {\n      const { circling, cards, removedCards } = this.data\n      if (circling) // 如果开启循环\n        current_cursor = current_cursor + 1 === cards.length ? 0 : current_cursor + 1\n      else\n        current_cursor += 1\n      if (!removedCards.includes(current_cursor)) return current_cursor\n      return this.countCurrentCursor(current_cursor)\n    }\n  }\n})\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AAAA;AACA;AACA;AAFA;AAIA;AAAA;AACA;AACA;AAFA;AAIA;AAAA;AACA;AACA;AAFA;AAIA;AAAA;AACA;AACA;AAFA;AAtBA;AA4BA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AADA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAFA;AAIA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AADA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AADA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAnDA;AArDA;;;;A","sourceRoot":""}